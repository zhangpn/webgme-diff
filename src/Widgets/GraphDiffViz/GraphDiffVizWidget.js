/*globals define, WebGMEGlobal*/
/*jshint browser: true*/

/**
 * Generated by VisualizerGenerator 0.1.0 from webgme on Thu Feb 18 2016 17:31:34 GMT+0800 (CST).
 */

define(['js/Widgets/GraphViz/GraphVizWidget',
    'css!./styles/GraphDiffVizWidget.css'], function (GraphVizWidget) {
    'use strict';

    var GraphDiffVizWidget,
        WIDGET_CLASS = 'graph-diff-viz',
        DURATION = 750,
        MARGIN = 20,
        i = 0,
        CLOSED = 'closed',
        OPEN = 'open',
        LEAF = 'LEAF',
        OPENING = 'opening',
        CLOSING = 'CLOSING',
        NODE_SIZE = 15,
        TREE_LEVEL_DISTANCE = 180,
        IGNORED_KEYS = ["guid", "oGuids", "hash", "pointer", "set", "validPlugins", "CrossCuts", "meta", "childrenListChanged"];
    

    GraphDiffVizWidget = function (logger, container) {

        this._logger = logger.fork('Widget');

        this._el = container;

        this.nodes = {};
        this._initialize();
        this._initZoom();

        this._logger.debug('ctor finished');

        this.nodeDataByPath = {};
        this.idToBaseNodes = {};
    };

    _.extend(GraphDiffVizWidget.prototype, GraphVizWidget.prototype);

    /* * * * * * * * Visualizer event handlers * * * * * * * */

    GraphDiffVizWidget.prototype.onNodeClick = function (id) {
        // This currently changes the active node to the given id and
        // this is overridden in the controller.
    };

    GraphDiffVizWidget.prototype.onBackgroundDblClick = function () {
        //this._el.append('<div>Background was double-clicked!!</div>');
    };

    /* * * * * * * * Visualizer life cycle callbacks * * * * * * * */
    GraphDiffVizWidget.prototype.destroy = function () {
    };

    GraphDiffVizWidget.prototype._update = function (source) {
        var self = this;

        // Compute the new tree layout.
        var nodes = this._tree.nodes(this._root).reverse(),
            links = this._tree.links(nodes);

        self._updateDiffObjs(nodes, links);

        var diagonal = d3.svg.diagonal()
            .projection(function (d) {
                return [d.y, d.x];
            });

        var getOpenStatus = function (d) {
            var status = LEAF;

            if (d.childrenNum > 0) {
                status = CLOSED;

                if (d.children && d.children.length === d.childrenNum) {
                    status = OPEN;
                }
            }

            return status;
        };

        // Normalize for fixed-depth.
        nodes.forEach(function (d) {
            d.y = d.depth * TREE_LEVEL_DISTANCE;
            d.status = d.status || getOpenStatus(d);
        });

        // Update the nodes ...
        var node = this._svg.selectAll('g.node')
            .data(nodes, function (d) {
                return d.id || (d.id = ++i);
            });

        var getDisplayName = function (d) {
            var n = d.name;

            if (d.childrenNum > 0) {
                n += ' [' + d.childrenNum + ']';
            }

            return n;
        };

        // Enter any new nodes at the parent's previous position.
        var nodeEnter = node.enter().append('g')
            .attr('class', 'node')
            .attr('transform', function (d) {
                return d.parent ?
                'translate(' + d.parent.y0 + ',' + d.parent.x0 + ')' : 'translate(' + d.y + ',' + d.x + ')';
            })
            .on('click', function (d) {
                d3.event.stopPropagation();
                d3.event.preventDefault();
                self._onNodeClick(d);
            })
            .on('dblclick', function (d) {
                d3.event.preventDefault();
                d3.event.stopPropagation();
                self._onNodeDblClick(d);
            });

        nodeEnter.append('circle')
            .attr('r', 1e-6);

        nodeEnter.append('text')
            .attr('dy', '.35em')
            .style('fill-opacity', 1e-6);

        // Transition nodes to their new position.
        var nodeUpdate = node.transition()
            .duration(DURATION)
            .attr('transform', function (d) {
                return 'translate(' + d.y + ',' + d.x + ')';
            });
            //.attr('id', function(d) {
            //    return d.id;
            //});

        nodeUpdate.select('circle')
            .attr('r', function (d) {
                return self.nodeDataByPath[d.id] ? (self.nodeDataByPath[d.id].childMajorChange ? 7 : 4.5) : 4.5;
            })
            .style('stroke', function(d) {
                return self.nodeDataByPath[d.id] ? (self.nodeDataByPath[d.id].childMajorChange
                                                    ? 'red' : self.nodeDataByPath[d.id].childChange ? 'orange' : 'steelblue')
                                                    : 'steelblue';
            });

        nodeUpdate.select('circle')
            .style('fill', function (d) {
                var color;
                if (self.nodeDataByPath[d.id]) {
                    if (self.nodeDataByPath[d.id].added && self.nodeDataByPath[d.id].removed) {
                        color = 'purple';
                    } else if (self.nodeDataByPath[d.id].added) {
                        color = 'green';
                    } else if (self.nodeDataByPath[d.id].removed) {
                        color = 'red';
                    } else if (self.nodeDataByPath[d.id].attrChange || self.nodeDataByPath[d.id].regChange) {
                        color = 'gold';
                    }
                }

                if (!color) {
                    var status = d.status;
                    color = '#FFFFFF';
                    if (status === CLOSED) {
                        color = 'lightsteelblue';
                    } else if (status === OPENING) {
                        color = '#ff0000';
                    } else if (status === OPEN) {
                        color = '#ffFFFF';
                    } else if (status === LEAF) {
                        color = '#ffFFFF';
                    } else if (status === CLOSING) {
                        color = '#00FF00';
                    }
                }

                return color;
            });

        nodeUpdate.select('text')
            .attr('x', function (d) {
                return (d.children && d.children.length > 0) ? -10 : 10;
            })
            .attr('text-anchor', function (d) {
                return (d.children && d.children.length > 0) ? 'end' : 'start';
            })
            .text(function (d) {
                return getDisplayName(d);
            })
            .style('fill-opacity', 1);

        // Transition exiting nodes to the parent's new position.
        var nodeExit = node.exit().transition()
            .duration(DURATION)
            .attr('transform', function (d) {
                return source ? 'translate(' + source.y + ',' + source.x + ')' :
                    d.parent ?
                    'translate(' + d.parent.y + ',' + d.parent.x + ')' : 'translate(' + d.y + ',' + d.x + ')';
            })
            .remove();

        nodeExit.select('circle')
            .attr('r', 1e-6);

        nodeExit.select('text')
            .style('fill-opacity', 1e-6);

        // Update the links ...
        var link = this._svg.selectAll('path.link')
            .data(links, function (d) {
                return d.target.id;
            });

        // Enter any new links at the parent's previous position.
        link.enter().insert('path', 'g')
            .attr('class', 'link')
            .attr('d', function (d) {
                var o = {x: d.source.x0 || d.source.y, y: d.source.y0 || d.source.y};
                return diagonal({source: o, target: o});
            });

        // Transition links to their new position.
        link.transition()
            .duration(DURATION)
            .attr('d', diagonal);

        // Transition exiting nodes to the parent's new position.
        link.exit().transition()
            .duration(DURATION)
            .attr('d', function (d) {
                var o = {x: d.source.x, y: d.source.y};
                return diagonal({source: o, target: o});
            })
            .remove();

        //node vertical positions by depth
        var nodesYByDepth = [];


        nodes.forEach(function (d) {
            // Stash the old positions for transition.
            d.x0 = d.x;
            d.y0 = d.y;

            // and query vertical coordinates of the nodes at the same depth to detect collision
            nodesYByDepth[d.depth] = nodesYByDepth[d.depth] || [];
            nodesYByDepth[d.depth].push(d.x);
        });

        //if already resizing, don't try to optimize again
        if (this.__resizing !== true) {
            var l = nodesYByDepth.length;
            var collideAtDepth = [];
            for (i = 1; i < l; i += 1) {
                //sort the coordinates for easy check of collision
                nodesYByDepth[i].sort(function (a, b) {
                    return a - b;
                });

                //see if any of the nodes overlap
                var j;
                var depthLength = nodesYByDepth[i].length;
                for (j = 0; j < depthLength - 1; j += 1) {
                    if (nodesYByDepth[i][j + 1] - NODE_SIZE <= nodesYByDepth[i][j]) {
                        collideAtDepth.push([i, depthLength]);
                        break;
                    }
                }
            }

            this._logger.debug('Collide:' + collideAtDepth);

            var sum = 0;
            var len = collideAtDepth.length;
            //start resize mode
            this.__resizing = true;

            if (len > 0) {
                while (len--) {
                    sum += collideAtDepth[len][1];
                }
            } else {
                //only the width changes
                sum = this._el.height() / NODE_SIZE;
            }


            this._resizeD3Tree(nodesYByDepth.length * TREE_LEVEL_DISTANCE, sum * NODE_SIZE);

            //redraw the tree
            this._update();

            //finish resize mode
            this.__resizing = false;
        }
    };


    GraphDiffVizWidget.prototype._updateDiffObjs = function (nodes, links) {
        var branch1 = 'master',
            branch2 = 'alter',
            projectId = WebGMEGlobal.Client.getProjectObject().projectId,
            url = "/api/projects/" + projectId.replace("+", "/") + "/compare/" + branch1 + "..." + branch2,
            diffObj = $.ajax({url: url, async: false}).responseJSON;


        this._processDiffObject(diffObj);

    };

    GraphDiffVizWidget.prototype._processDiffObject = function (diff) {
        // recursively get each diff
        var self = this,
            client = WebGMEGlobal.Client,
            path,
            i,
            node = self.rootNode;

        for (i in diff) {
            if (diff.hasOwnProperty(i)) {
                // todo: skip guid and oGuids for now but use this info for later
                if (IGNORED_KEYS.indexOf(i) > -1) continue;
                if (i === "attr") {
                    node.attrChange = true;
                } else if (i === "reg") {
                    node.regChange = true;
                } else {
                    path = "/" + i;
                    node = client.getNode(path);
                    // todo: directly store this data at node
                    if (!self.nodeDataByPath[path]) {
                        self.nodeDataByPath[path] = {};
                    }
                    self._processDiffObjectRec(diff[i], path, node);
                }
                // get node from path

            }
        }

    };


    GraphDiffVizWidget.prototype._processDiffObjectRec = function (diff, path, node) {
        // recursively get each diff
        var self = this,
            client = WebGMEGlobal.Client,
            i;

        for (i in diff) {
            if (diff.hasOwnProperty(i)) {
                // todo: skip guid and oGuids for now but use this info for later
                if (IGNORED_KEYS.indexOf(i) > -1) continue;
                if (i === "attr") {
                    self.nodeDataByPath[path].attrChange = true;
                    if (self.nodeDataByPath[path].parentPath) {
                        self.nodeDataByPath[self.nodeDataByPath[path].parentPath].childChange = true;
                    }
                } else if (i === "reg") {
                    self.nodeDataByPath[path].regChange = true;
                    if (self.nodeDataByPath[path].parentPath) {
                        self.nodeDataByPath[self.nodeDataByPath[path].parentPath].childChange = true;
                    }
                } else if (i === "removed") {
                    self.nodeDataByPath[self.nodeDataByPath[path].parentPath].childMajorChange = true;
                    if (diff[i]) {
                        self.nodeDataByPath[path].removed = true;
                    } else {
                        self.nodeDataByPath[path].added = true;
                    }
                } else {
                    node = client.getNode(path + "/" + i);
                    if (node) {
                        //self._openNode(path);
                        // todo: directly store this data at node
                        if (!self.nodeDataByPath[path + "/" + i]) {
                            self.nodeDataByPath[path + "/" + i] = {};
                            self.nodeDataByPath[path + "/" + i].parentPath = path;
                        }
                        self._processDiffObjectRec(diff[i], path + "/" + i, node);
                    } else {
                        //node =
                        //if ()
                         if (diff[i].pointer && diff[i].pointer["base"]) {
                            self.idToBaseNodes[path + "/" + i] = diff[i].pointer["base"];
                        }
                    }

                }
                // get node from path
            }
        }
    };


    return GraphDiffVizWidget;
});
